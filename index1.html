<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Dodge Falling Blocks 3D — Perfect Edition</title>
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  
  <style>
    :root {
      --ui-bg: rgba(0,0,0,.55);
      --ui-bg-strong: rgba(0,0,0,.75);
    }
    html, body { height: 100%; }
    body { margin: 0; overflow: hidden; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji"; }
    /* Fullscreen canvas holder */
    #app { position: fixed; inset: 0; }
    canvas { display: block; width: 100vw; height: 100vh; outline: none; }

    /* HUD */
    .hud { position: fixed; inset: 0; pointer-events: none; }
    .hud * { pointer-events: auto; }

    /* Glass panels */
    .glass { backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); background: var(--ui-bg); box-shadow: 0 20px 40px rgba(0,0,0,.35); }

    /* Mobile touch controls */
    .touch-btn { width: 80px; height: 80px; border-radius: 9999px; display: grid; place-items: center; user-select: none; -webkit-tap-highlight-color: transparent; }

    /* Animations */
    .fade-in { animation: fade-in .35s ease both; }
    @keyframes fade-in { from { opacity: 0; transform: translateY(6px) scale(.98); } }

    /* Simple gradient sky background (behind WebGL) */
    #bg { position: fixed; inset: 0; background: radial-gradient(120% 120% at 50% 0%, #172554 0%, #0b1220 60%, #05080f 100%); z-index: -1; }
  </style>
</head>
<body>
  <div id="bg"></div>
  <div id="app"></div>

  <!-- HUD / UI -->
  <div class="hud">
    <!-- Top status bar (hidden initially) -->
    <div id="game-hud" class="absolute left-1/2 -translate-x-1/2 top-4 flex items-center gap-3 px-4 py-2 rounded-full glass text-white text-base sm:text-lg opacity-0 transition-opacity duration-300">
      <div class="font-semibold">Score: <span id="ui-score">0</span></div>
      <div class="font-semibold">Lives: <span id="ui-lives">3</span></div>
      <div class="font-semibold hidden sm:block">Best: <span id="ui-best">0</span></div>
      <button id="btn-pause" class="ml-2 px-3 py-1 rounded-full bg-white/10 hover:bg-white/20 transition text-sm">Pause</button>
      <button id="btn-settings" class="px-3 py-1 rounded-full bg-white/10 hover:bg-white/20 transition text-sm">Settings</button>
    </div>

    <!-- Center messages -->
    <div id="ui-banner" class="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 text-center text-white w-full max-w-md px-4">
      <!-- Content is generated by JavaScript -->
    </div>

    <!-- Bottom mobile controls (hidden initially) -->
    <div id="touch-controls" class="absolute bottom-6 left-1/2 -translate-x-1/2 md:hidden opacity-0 transition-opacity duration-300">
      <div class="flex items-center gap-6">
        <button id="btn-left" aria-label="Move left" class="touch-btn glass text-white active:scale-95 transition">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="36" height="36" fill="currentColor"><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/></svg>
        </button>
        <button id="btn-right" aria-label="Move right" class="touch-btn glass text-white active:scale-95 transition">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="36" height="36" fill="currentColor"><path d="M8.59 16.59L10 18l6-6-6-6-1.41 1.41L13.17 12z"/></svg>
        </button>
      </div>
    </div>
  </div>

  <!-- Settings Drawer -->
  <div id="drawer" class="fixed right-4 top-4 w-[300px] max-w-[90vw] text-white glass rounded-2xl p-4 hidden z-10">
    <div class="flex items-center justify-between">
      <h2 class="text-lg font-semibold">Settings</h2>
      <button id="btn-close-settings" class="px-2 py-1 rounded-lg bg-white/10 hover:bg-white/20 text-sm">Close</button>
    </div>
    <div class="mt-3 space-y-4">
      <div>
        <label class="text-sm">Sensitivity</label>
        <input id="inp-sens" type="range" min="0.5" max="2.0" step="0.1" value="1" class="w-full">
      </div>
      <div>
        <label class="text-sm">Volume</label>
        <input id="inp-vol" type="range" min="0" max="1" step="0.05" value="0.5" class="w-full">
      </div>
      <div>
        <label class="text-sm">Graphics</label>
        <select id="sel-gfx" class="mt-1 w-full bg-white/10 rounded-lg p-2">
          <option value="high">High (shadows)</option>
          <option value="medium">Medium</option>
          <option value="low">Low</option>
        </select>
      </div>
      <div class="text-xs text-white/70">Changes apply immediately. Graphics may reduce battery usage on mobile.</div>
    </div>
  </div>

  <script>
  // =========================
  // Utility & Audio helpers
  // =========================
  const clamp = (n, a, b) => Math.min(Math.max(n, a), b);
  const randRange = (a, b) => a + Math.random() * (b - a);

  class Beeper {
    constructor() { this.ctx = null; this.gain = null; this.volume = 0.5; }
    ensure() {
      if (this.ctx) return;
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const gain = ctx.createGain(); gain.gain.value = this.volume; gain.connect(ctx.destination);
      this.ctx = ctx; this.gain = gain;
    }
    setVolume(v) { this.volume = v; if (this.gain) this.gain.gain.value = v; }
    beep(freq = 880, dur = 0.08, type = 'square') {
      this.ensure();
      const o = this.ctx.createOscillator(); const g = this.ctx.createGain();
      o.type = type; o.frequency.value = freq; g.gain.value = this.volume;
      o.connect(g); g.connect(this.gain);
      const t = this.ctx.currentTime;
      o.start(t); g.gain.setTargetAtTime(0, t + dur * 0.4, dur * 0.5); o.stop(t + dur);
    }
  }
  const beeper = new Beeper();

  // =========================
  // Game constants
  // =========================
  const WORLD = { width: 120, depth: 60, height: 160 };
  const PLAYER = { w: 10, h: 6, d: 8, maxSpeed: 40 };
  const OBST = { min: 6, max: 16 };

  // Difficulty Levels & Settings
  const LEVELS = {
    easy:     { name: 'Easy',     INIT: { lives: 5, spawnEvery: 1.2, speed: 10 }, DIFF: { speedPerMin: 6,  spawnFasterPerMin: 0.25, maxFallSpeed: 45, minSpawn: 0.3 } },
    moderate: { name: 'Moderate', INIT: { lives: 3, spawnEvery: 0.8, speed: 14 }, DIFF: { speedPerMin: 10, spawnFasterPerMin: 0.3,  maxFallSpeed: 55, minSpawn: 0.22 } },
    hard:     { name: 'Hard',     INIT: { lives: 3, spawnEvery: 0.65, speed: 20}, DIFF: { speedPerMin: 15, spawnFasterPerMin: 0.4,  maxFallSpeed: 70, minSpawn: 0.18 } },
    insane:   { name: 'Insane',   INIT: { lives: 1, spawnEvery: 0.5, speed: 28 }, DIFF: { speedPerMin: 25, spawnFasterPerMin: 0.5,  maxFallSpeed: 90, minSpawn: 0.15 } }
  };

  // Graphics presets
  const GFX = { high: { shadows: true }, medium: { shadows: false }, low: { shadows: false } };

  // =========================
  // Three.js setup
  // =========================
  let renderer, scene, camera, clock;
  let ground, hemiLight, dirLight;
  const appEl = document.getElementById('app');

  function initThree(gfxQuality = 'high') {
    scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x0b1220, 120, 260);
    camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 600);
    camera.position.set(0, 48, 105);
    camera.lookAt(0, 10, 0);
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.shadowMap.enabled = GFX[gfxQuality].shadows;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    appEl.innerHTML = '';
    appEl.appendChild(renderer.domElement);
    hemiLight = new THREE.HemisphereLight(0x6aa7ff, 0x0c1224, 0.85);
    scene.add(hemiLight);
    dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
    dirLight.position.set(60, 100, 40);
    dirLight.castShadow = GFX[gfxQuality].shadows;
    dirLight.shadow.mapSize.set(1024, 1024);
    dirLight.shadow.camera.near = 1; dirLight.shadow.camera.far = 280;
    dirLight.shadow.camera.left = -120; dirLight.shadow.camera.right = 120;
    dirLight.shadow.camera.top = 140; dirLight.shadow.camera.bottom = -60;
    scene.add(dirLight);
    const g = new THREE.PlaneBufferGeometry(WORLD.width, WORLD.depth, 1, 1);
    const m = new THREE.MeshStandardMaterial({ color: 0x0f1a33, roughness: 0.9, metalness: 0.0 });
    ground = new THREE.Mesh(g, m);
    ground.rotation.x = -Math.PI / 2;
    ground.position.set(0, -WORLD.height * 0.3, 0);
    ground.receiveShadow = true;
    scene.add(ground);
    const grid = new THREE.GridHelper(WORLD.width, 20, 0x2a3b6b, 0x1b2a52);
    grid.position.y = ground.position.y + 0.02;
    scene.add(grid);
    clock = new THREE.Clock();
  }

  // =========================
  // Entities: Player & Obstacles
  // =========================
  class Player {
    constructor() {
      const geo = new THREE.BoxBufferGeometry(PLAYER.w, PLAYER.h, PLAYER.d);
      const mat = new THREE.MeshStandardMaterial({ color: 0xf1c40f, roughness: 0.35, metalness: 0.1 });
      this.mesh = new THREE.Mesh(geo, mat);
      this.mesh.castShadow = true;
      this.mesh.position.set(0, ground.position.y + PLAYER.h / 2 + 2, 0);
      scene.add(this.mesh);
      this.vel = 0; this.targetDir = 0; this.sensitivity = 1.0;
    }
    setSensitivity(s) { this.sensitivity = s; }
    update(dt) {
      const accel = 70 * this.sensitivity; const friction = 12;
      const desired = this.targetDir * PLAYER.maxSpeed;
      const delta = desired - this.vel;
      const impulse = clamp(delta, -accel, accel);
      this.vel += impulse * dt;
      if (this.targetDir === 0) {
        const f = Math.sign(this.vel) * Math.min(Math.abs(this.vel), friction);
        this.vel -= f * dt;
      }
      this.mesh.position.x += this.vel * dt;
      const halfW = WORLD.width * 0.5 - PLAYER.w * 0.55;
      this.mesh.position.x = clamp(this.mesh.position.x, -halfW, halfW);
      this.mesh.rotation.z = THREE.MathUtils.lerp(this.mesh.rotation.z, -this.vel * 0.01, 8 * dt);
    }
    reset() { this.vel = 0; this.targetDir = 0; this.mesh.position.x = 0; this.mesh.rotation.z = 0; }
  }

  class ObstaclePool {
    constructor() { this.pool = []; }
    get() { return this.pool.pop() || this.create(); }
    release(obj) { obj.mesh.visible = false; this.pool.push(obj); }
    create() {
      const size = randRange(OBST.min, OBST.max);
      const geo = new THREE.BoxBufferGeometry(size, size, size);
      const mat = new THREE.MeshStandardMaterial({ color: new THREE.Color().setHSL(Math.random(), 0.6, 0.5) });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.castShadow = true; mesh.receiveShadow = false; mesh.visible = false;
      scene.add(mesh);
      return { mesh, size, speed: 0, rot: new THREE.Vector3(randRange(-1,1), randRange(-1,1), randRange(-1,1)) };
    }
  }

  class Obstacles {
    constructor() {
      this.pool = new ObstaclePool();
      this.live = []; this.spawnTimer = 0; this.spawnEvery = 1; this.fallSpeed = 10; this.maxLive = 80;
    }
    update(dt, elapsed) {
      const level = LEVELS[GameState.level];
      this.fallSpeed = clamp(level.INIT.speed + level.DIFF.speedPerMin * (elapsed / 60), level.INIT.speed, level.DIFF.maxFallSpeed);
      this.spawnEvery = clamp(level.INIT.spawnEvery - level.DIFF.spawnFasterPerMin * (elapsed / 60), level.DIFF.minSpawn, level.INIT.spawnEvery);

      this.spawnTimer += dt;
      if (this.spawnTimer >= this.spawnEvery && this.live.length < this.maxLive) {
        this.spawnTimer = 0;
        const o = this.pool.get();
        const s = randRange(OBST.min, OBST.max);
        o.size = s;
        o.mesh.scale.setScalar(1);
        o.mesh.position.set(randRange(-WORLD.width*0.5+s, WORLD.width*0.5-s), ground.position.y + WORLD.height*0.6 + s, randRange(-WORLD.depth*0.25, WORLD.depth*0.25));
        o.speed = this.fallSpeed * randRange(0.9, 1.15);
        o.rot.set(randRange(-1,1), randRange(-1,1), randRange(-1,1));
        o.mesh.rotation.set(randRange(0, Math.PI), randRange(0, Math.PI), randRange(0, Math.PI));
        o.mesh.material.color.setHSL(Math.random(), 0.6, 0.5);
        o.mesh.visible = true;
        this.live.push(o);
      }

      for (let i = this.live.length - 1; i >= 0; i--) {
        const o = this.live[i];
        o.mesh.position.y -= o.speed * dt;
        o.mesh.rotation.x += o.rot.x * dt; o.mesh.rotation.y += o.rot.y * dt; o.mesh.rotation.z += o.rot.z * dt;
        if (o.mesh.position.y < ground.position.y - o.size * 1.5) {
          GameState.score += 1;
          beeper.beep(1200, 0.05, 'sine');
          this.pool.release(o);
          this.live.splice(i, 1);
        }
      }
    }
    clear() {
      for (const o of this.live) this.pool.release(o);
      this.live.length = 0;
      this.spawnTimer = 0;
    }
  }

  // =========================
  // Game State & Manager
  // =========================
  const GameState = {
    running: false, paused: false, lives: 3, score: 0, best: 0, elapsed: 0, level: 'moderate',
  };

  let player, obstacles;

  // UI elements
  const gameHud = document.getElementById('game-hud');
  const touchControls = document.getElementById('touch-controls');
  const uiScore = document.getElementById('ui-score');
  const uiLives = document.getElementById('ui-lives');
  const uiBest  = document.getElementById('ui-best');
  const banner  = document.getElementById('ui-banner');
  const btnPause = document.getElementById('btn-pause');
  const btnSettings = document.getElementById('btn-settings');
  const drawer = document.getElementById('drawer');
  const btnCloseSettings = document.getElementById('btn-close-settings');
  const inpSens = document.getElementById('inp-sens');
  const inpVol = document.getElementById('inp-vol');
  const selGfx = document.getElementById('sel-gfx');
  const btnLeft = document.getElementById('btn-left');
  const btnRight = document.getElementById('btn-right');

  // --- Local Storage for Scores and State ---
  const STORAGE_KEYS = { BEST: 'perfect_blocks_best', STATE: 'perfect_blocks_state' };
  function loadBest() {
    try { GameState.best = parseInt(localStorage.getItem(STORAGE_KEYS.BEST) || '0', 10) || 0; } catch { GameState.best = 0; }
    uiBest.textContent = GameState.best;
  }
  function saveBest() {
    try { localStorage.setItem(STORAGE_KEYS.BEST, String(GameState.best)); } catch {}
  }
  function saveGameState() {
    const state = { score: GameState.score, lives: GameState.lives, elapsed: GameState.elapsed, level: GameState.level };
    try { localStorage.setItem(STORAGE_KEYS.STATE, JSON.stringify(state)); } catch {}
  }
  function loadGameState() {
    try { return JSON.parse(localStorage.getItem(STORAGE_KEYS.STATE)); } catch { return null; }
  }
  function clearGameState() {
    try { localStorage.removeItem(STORAGE_KEYS.STATE); } catch {}
  }

  // --- UI Banner Functions ---
  function setBanner(html) {
    banner.innerHTML = `<div class="glass rounded-2xl p-6 sm:p-8 fade-in text-white text-center">${html}</div>`;
  }

  function showMainMenu() {
    const savedState = loadGameState();
    setBanner(`
      <h1 class="text-3xl sm:text-5xl font-black drop-shadow-sm">Dodge Falling Blocks 3D</h1>
      <div class="mt-6 flex flex-col items-center justify-center gap-3">
        <button id="_new" class="w-full max-w-xs px-5 py-2.5 rounded-xl bg-emerald-500 hover:bg-emerald-600 transition font-semibold text-lg">New Game</button>
        <button id="_continue" class="w-full max-w-xs px-5 py-2.5 rounded-xl bg-sky-500 hover:bg-sky-600 transition font-semibold text-lg ${!savedState ? 'opacity-50 cursor-not-allowed' : ''}">Continue</button>
        <button id="_scores" class="w-full max-w-xs px-5 py-2.5 rounded-xl bg-white/10 hover:bg-white/20 transition font-semibold text-lg">High Scores</button>
      </div>
    `);
    document.getElementById('_new').onclick = showLevelSelect;
    document.getElementById('_scores').onclick = showHighScores;
    const continueBtn = document.getElementById('_continue');
    if (savedState) {
      continueBtn.onclick = continueGame;
    }
  }
  
  function showLevelSelect() {
    setBanner(`
      <h2 class="text-2xl sm:text-4xl font-black">Select Difficulty</h2>
      <div class="mt-4 grid grid-cols-2 gap-3">
        <button data-level="easy" class="px-4 py-3 rounded-xl bg-green-500/80 hover:bg-green-500 transition font-semibold">Easy</button>
        <button data-level="moderate" class="px-4 py-3 rounded-xl bg-yellow-500/80 hover:bg-yellow-500 transition font-semibold">Moderate</button>
        <button data-level="hard" class="px-4 py-3 rounded-xl bg-orange-500/80 hover:bg-orange-500 transition font-semibold">Hard</button>
        <button data-level="insane" class="px-4 py-3 rounded-xl bg-red-600/80 hover:bg-red-600 transition font-semibold">Insane</button>
      </div>
      <div class="mt-4">
        <button id="_back" class="px-5 py-2 rounded-xl bg-white/10 hover:bg-white/20 transition font-semibold">Back</button>
      </div>
    `);
    banner.querySelectorAll('[data-level]').forEach(btn => {
      btn.onclick = () => startGame(btn.dataset.level);
    });
    document.getElementById('_back').onclick = showMainMenu;
  }

  function showHighScores() {
      // For now, we only have one high score. This can be expanded later.
      loadBest();
      setBanner(`
        <h2 class="text-2xl sm:text-4xl font-black">High Score</h2>
        <div class="mt-4 text-3xl font-bold">${GameState.best}</div>
        <div class="mt-4">
            <button id="_back" class="px-5 py-2 rounded-xl bg-white/10 hover:bg-white/20 transition font-semibold">Back</button>
        </div>
      `);
      document.getElementById('_back').onclick = showMainMenu;
  }

  function showGameOver() {
    clearGameState();
    const newBest = Math.max(GameState.best, GameState.score);
    if (newBest > GameState.best) { GameState.best = newBest; saveBest(); }
    setBanner(`
      <h2 class="text-3xl sm:text-5xl font-black">Game Over</h2>
      <div class="mt-2 text-white/80">Level: <span class="font-semibold">${LEVELS[GameState.level].name}</span></div>
      <div class="mt-1 text-white/80">Score: <span class="font-semibold">${GameState.score}</span> · Best: <span class="font-semibold">${GameState.best}</span></div>
      <div class="mt-4 flex flex-wrap items-center justify-center gap-3">
        <button id="_restart" class="px-5 py-2.5 rounded-xl bg-rose-500 hover:bg-rose-600 transition font-semibold">Play Again</button>
        <button id="_menu" class="px-5 py-2.5 rounded-xl bg-white/10 hover:bg-white/20 transition font-semibold">Main Menu</button>
      </div>
    `);
    document.getElementById('_restart').onclick = () => startGame(GameState.level);
    document.getElementById('_menu').onclick = showMainMenu;
  }

  function setGameUIVisible(visible) {
      const opacity = visible ? '1' : '0';
      gameHud.style.opacity = opacity;
      touchControls.style.opacity = opacity;
  }

  function startGame(level) {
    clearGameState();
    banner.innerHTML = '';
    setGameUIVisible(true);

    GameState.running = true;
    GameState.paused = false;
    GameState.level = level;
    const levelSettings = LEVELS[level].INIT;
    GameState.lives = levelSettings.lives;
    GameState.score = 0;
    GameState.elapsed = 0;
    
    player.reset();
    obstacles.clear();
    uiLives.textContent = GameState.lives;
    uiScore.textContent = GameState.score;
    loadBest(); // Ensure best score is up to date
  }

  function continueGame() {
      const savedState = loadGameState();
      if (!savedState) {
          showMainMenu();
          return;
      }
      banner.innerHTML = '';
      setGameUIVisible(true);

      GameState.running = true;
      GameState.paused = false;
      GameState.level = savedState.level;
      GameState.lives = savedState.lives;
      GameState.score = savedState.score;
      GameState.elapsed = savedState.elapsed;

      player.reset();
      obstacles.clear(); // Obstacles are not saved, they will respawn
      uiLives.textContent = GameState.lives;
      uiScore.textContent = GameState.score;
      loadBest();
  }

  function loseLife() {
    if (!GameState.running) return;
    GameState.lives -= 1;
    uiLives.textContent = GameState.lives;
    beeper.beep(220, 0.18, 'sawtooth');
    flashHit();
    if (GameState.lives <= 0) {
      GameState.running = false;
      setGameUIVisible(false);
      showGameOver();
    }
  }

  let flashEl;
  function flashHit() {
    if (!flashEl) {
      flashEl = document.createElement('div');
      Object.assign(flashEl.style, {
        position: 'fixed', inset: '0', background: 'rgba(255,0,0,.18)',
        pointerEvents: 'none', transition: 'opacity .18s ease', opacity: '0'
      });
      document.body.appendChild(flashEl);
    }
    flashEl.style.opacity = '1';
    setTimeout(() => flashEl.style.opacity = '0', 40);
  }

  // =========================
  // Input (keyboard + mobile)
  // =========================
  const Keys = { left: false, right: false };
  function updateInputFromKeys() { player.targetDir = (Keys.left ? -1 : 0) + (Keys.right ? 1 : 0); }
  window.addEventListener('keydown', e => {
    if (e.repeat) return;
    if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') { Keys.left = true; updateInputFromKeys(); }
    if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') { Keys.right = true; updateInputFromKeys(); }
    if (e.key.toLowerCase() === 'p') togglePause();
  });
  window.addEventListener('keyup', e => {
    if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') { Keys.left = false; updateInputFromKeys(); }
    if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') { Keys.right = false; updateInputFromKeys(); }
  });
  const startHold = (dir) => { player.targetDir = dir; };
  const stopHold = () => { if (!Keys.left && !Keys.right) player.targetDir = 0; else updateInputFromKeys(); };
  const addHoldEvents = (el, dir) => {
    el.addEventListener('touchstart', e => { e.preventDefault(); startHold(dir); }, { passive: false });
    el.addEventListener('touchend', e => { e.preventDefault(); stopHold(); }, { passive: false });
    el.addEventListener('mousedown', () => startHold(dir));
    el.addEventListener('mouseup', stopHold);
    el.addEventListener('mouseleave', stopHold);
  };
  addHoldEvents(btnLeft, -1);
  addHoldEvents(btnRight, 1);

  // =========================
  // Collision helper
  // =========================
  const tmpBoxA = new THREE.Box3();
  const tmpBoxB = new THREE.Box3();
  function intersectsAABB(meshA, meshB) {
    tmpBoxA.setFromObject(meshA);
    tmpBoxB.setFromObject(meshB);
    return tmpBoxA.intersectsBox(tmpBoxB);
  }

  // =========================
  // Main loop
  // =========================
  function renderLoop() {
    const dt = clock.getDelta();
    if (GameState.running && !GameState.paused) {
      GameState.elapsed += dt;
      player.update(dt);
      obstacles.update(dt, GameState.elapsed);
      for (let i = obstacles.live.length - 1; i >= 0; i--) {
        const o = obstacles.live[i];
        if (intersectsAABB(player.mesh, o.mesh)) {
          obstacles.pool.release(o);
          obstacles.live.splice(i, 1);
          loseLife();
          break;
        }
      }
      uiScore.textContent = GameState.score;
    }
    camera.position.x = THREE.MathUtils.lerp(camera.position.x, player.mesh.position.x * 0.65, 5 * dt);
    camera.lookAt(new THREE.Vector3(player.mesh.position.x * 0.2, 10, 0));
    renderer.render(scene, camera);
    requestAnimationFrame(renderLoop);
  }

  // =========================
  // Pause / Settings / Resize
  // =========================
  function togglePause() {
    if (!GameState.running) return;
    GameState.paused = !GameState.paused;
    btnPause.textContent = GameState.paused ? 'Resume' : 'Pause';

    if (GameState.paused) {
      saveGameState();
      setBanner(`
        <h3 class='text-2xl sm:text-4xl font-black'>Paused</h3>
        <div class='mt-2 text-white/80'>Your progress is saved.</div>
        <div class="mt-4 flex flex-col items-center justify-center gap-3">
            <button id="_resume" class="w-full max-w-xs px-5 py-2.5 rounded-xl bg-sky-500 hover:bg-sky-600 transition font-semibold text-lg">Resume</button>
            <button id="_menu" class="w-full max-w-xs px-5 py-2.5 rounded-xl bg-white/10 hover:bg-white/20 transition font-semibold text-lg">Main Menu</button>
        </div>
      `);
      
      document.getElementById('_resume').onclick = togglePause;
      document.getElementById('_menu').onclick = () => {
          GameState.running = false;
          GameState.paused = false;
          setGameUIVisible(false);
          showMainMenu();
      };
    } else {
      banner.innerHTML = '';
    }
  }

  btnPause.onclick = togglePause;
  btnSettings.onclick = () => { drawer.classList.toggle('hidden'); };
  btnCloseSettings.onclick = () => { drawer.classList.add('hidden'); };
  inpSens.oninput = (e) => player.setSensitivity(parseFloat(e.target.value));
  inpVol.oninput = (e) => beeper.setVolume(parseFloat(e.target.value));
  selGfx.onchange = (e) => {
    initThree(e.target.value);
    const oldSens = player ? player.sensitivity : 1;
    player = new Player();
    player.setSensitivity(oldSens);
    obstacles = new Obstacles();
    // Game state is not restored on gfx change, user must restart.
    setGameUIVisible(false);
    showMainMenu();
  };

  window.addEventListener('resize', () => {
    if (!renderer || !camera) return;
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
  });

  // =========================
  // Boot
  // =========================
  function boot() {
    loadBest();
    initThree('high');
    player = new Player();
    obstacles = new Obstacles();
    player.setSensitivity(parseFloat(inpSens.value));
    beeper.setVolume(parseFloat(inpVol.value));
    showMainMenu();
    renderLoop();
  }

  window.addEventListener('load', boot, { once: true });
  </script>
</body>
</html>
